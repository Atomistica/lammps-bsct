# Point charges approaches subbstrate (Na+ anc Cl- above Au(111))

variable cathode_type         index 1     # type of substrate (Au)
variable anode_type           index 2     # type of substrate (Au)
variable cation_type          index 3     # type of cation (Na+)
variable anion_type           index 4     # type of anion (Cl-)
variable ion_charge           index 1.0   # charge of Na+ in "real units": elementary charge
variable electrode_charge_scale_factor index 0.0
variable vel                  index 0.01 # approach velocity (ang/fs)
variable timestep             index 2.0   # fs

variable hubbard_u_in_eV      index 6.8 # eV

variable eV_to_kcal           index 3.82929e-23 
variable eV_to_kcal_per_mole  index 23.0605 

variable joule_to_kcal        index 0.239e-3    # conversion from J to kcal (kcal / J)
variable delta_phi            index 0.00        # potential difference between electrodes (V)
variable faraday_constant     index 96485.33212 # C / mol

variable hubbard_u            equal "v_hubbard_u_in_eV * v_eV_to_kcal_per_mole"

units           real

boundary        p p f
neigh_modify    delay 0 every 1 check yes

atom_style      full

# include coeffs.setup

read_data       minimized.lammps

group cathode type  ${cathode_type}
group anode type    ${anode_type}
group capacitor     union cathode anode

variable lower_interface_z equal "bound(cathode,zmax)"
variable upper_interface_z equal "bound(anode,zmin)"
variable hvac              equal "v_upper_interface_z - v_lower_interface_z"

print           """
  Inter-plate distance d = $(v_hvac:%.2e) ang between lower interface at
  z_0 = $(v_lower_interface_z:%.2e) and upper interface at z_1 = $(v_upper_interface_z:%.2e).
              """
variable cation_x equal "1.0/4.0*(xhi - xlo)"
variable anion_x  equal "3.0/4.0*(xhi - xlo)"
variable cation_y equal "1.0/4.0*(yhi - ylo)"
variable anion_y  equal "3.0/4.0*(yhi - ylo)"

variable cation_z equal "(v_lower_interface_z + v_upper_interface_z)/2.0"
variable anion_z equal  "(v_lower_interface_z + v_upper_interface_z)/2.0"

variable dz                   equal "v_cation_z - v_lower_interface_z" # initial distance between ion and substrate (ang)
variable nsteps               equal "round( abs( v_dz / v_vel / v_timestep ) )"

create_atoms ${cation_type} single ${cation_x} ${cation_y} ${cation_z}
create_atoms ${anion_type} single ${anion_x} ${anion_y} ${anion_z}

set type ${cation_type} charge ${ion_charge}
set type ${anion_type}  charge -${ion_charge}

print           """
    Cation placed at (x,y,z) = ( ${cation_x}, ${cation_y}, ${cation_z} ) ang.
    Anion  placed at (x,y,z) = ( ${anion_x}, ${anion_y}, ${anion_z} ) ang.
                """

group anions    type  ${anion_type}
group cations   type  ${cation_type}
group ions      union anions cations

pair_style      coul/long/bsct 12.0
pair_coeff      * *
pair_modify     table 0
kspace_style    pppm/bsct 1.0e-6
kspace_modify   slab 3.0 mesh 5 5 80 order 7
# The mesh keyword sets the grid size for kspace style pppm or msm. In the case
# of PPPM, this is the FFT mesh, and each dimension must be factorizable into
# powers of 2, 3, and 5. In the case of MSM, this is the finest scale real-space
# mesh, and each dimension must be factorizable into powers of 2. When this
# option is not set, the PPPM or MSM solver chooses its own grid size,
# consistent with the user-specified accuracy and pairwise cutoff. Values for
# x,y,z of 0,0,0 unset the option.
#
# The order keyword determines how many grid spacings an atom's charge extends
# when it is mapped to the grid in kspace style pppm or msm. The default for
# this parameter is 5 for PPPM and 8 for MSM, which means each charge spans 5 or
# 8 grid cells in each dimension, respectively. For the LAMMPS implementation of
# MSM, the order can range from 4 to 10 and must be even. For PPPM, the minimum
# allowed setting is 2 and the maximum allowed setting is 7. The larger the
# value of this parameter, the smaller that LAMMPS will set the grid size, to
# achieve the requested accuracy. Conversely, the smaller the order value, the
# larger the grid size will be. Note that there is an inherent trade-off
# involved: a small grid will lower the cost of FFTs or MSM direct sum, but a
# larger order parameter will increase the cost of interpolating charge/fields
# to/from the grid.

change_box all z final $(zlo) $(2*zhi)


neighbor        1.0 bin
neigh_modify    delay 0 every 1 check yes

timestep        ${timestep}

print           """
    Cation at initial distance dz = $(v_dz:%.2e) ang approaches substrate
    at velocity v = $(v_vel:%.2e) ang / fs over $(v_nsteps) time steps
    of ${timestep} fs each.
                """

variable        n_cathode  equal "count(cathode)"
variable        cathode_pcharge equal "-v_ion_charge / v_n_cathode"

variable        n_anode  equal "count(anode)"
variable        anode_pcharge equal "v_ion_charge / v_n_anode"
 
print           """
    Uniformly distribute initial charge Q_c = -${ion_charge} onto
    $(v_n_cathode) cathode atoms at partial charge q_c = $(v_cathode_pcharge:%.4e) each
    and Q_a = +${ion_charge} onto
    $(v_n_anode) anode atoms at partial charge q_a = $(v_anode_pcharge:%.4e) each
                """

set             group cathode charge $(v_electrode_charge_scale_factor*v_cathode_pcharge)
set             group anode charge $(v_electrode_charge_scale_factor*v_anode_pcharge)


variable delta_mubar equal "v_joule_to_kcal * v_faraday_constant * v_delta_phi"

print           """
    Potential difference of delta_phi = $(v_delta_phi:%.2e) V
    corresponds to electrochemical potential difference of
    delta_mu = $(v_delta_mubar:%.2e) kcal / mol or $((v_delta_mubar/v_joule_to_kcal):%.2e) J / mol
                """

# BSCT FIX SYNTAX
# fix groupID bsct atomType X U V p keyword values
# X: chemical potential; U: Hubbard energy; V: band structure contributuon; p: exponent
# Note that U cannot be "0"
fix             ct capacitor bsct nevery 1 qtot 0.0 log 3 mode 2 history 10 &
                beta 0.1 prec 0.05 max_iter 1000 &
                type ${cathode_type} $(-v_delta_mubar/2.0) $(v_hubbard_u) 0.0 1.0 &
                type ${anode_type} $(v_delta_mubar/2.0)  $(v_hubbard_u) 0.0 1.0

fix_modify      ct energy yes

# fix             integrate ions nve

fix             move_cations  cations move linear 0.0 0.0 -${vel} units box
fix             move_anions   anions  move linear 0.0 0.0 ${vel} units box

thermo          1
thermo_style    custom step temp press etotal ke pe f_ct &
                ebond eangle edihed eimp epair evdwl ecoul elong etail
thermo_modify   format float %15.14g norm no

dump            1 all custom 1 dump.custom id mol type x y z q f_ct
dump_modify     1 format line "%d %d %d %f %f %f %15.14e %15.14e"

run             ${nsteps}

write_data      final.lammps
write_dump      all image final.png type type modify backcolor white
